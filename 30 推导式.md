# **一. 推导式**

本节我们讲列表推导式,生成器表达式以及其他推导式，我认为推导式就是构建比较有规律的列表,生成器，字典等一种简便的方式。那么他如何简便呢？看下面的例题：

### **1.1列表推导式**

**这里让学生自己做一下**，首先我们先看一下这样的代码,给出一个列表,通过循环,想列表中添加1~10:

```
li = []

for i in range(10):

    li.append(i)

print(li)
```

那么按照上面的要求我们用列表推导式写一下：

```
ls = [i for i in range(10)]

print(ls)
```

怎么样？一行搞定，上面这个代码就是列表推导式，接下来我们将列表推导式进行一个分类：

**列表推导式分为两种模式：**

​    1.循环模式：[变量(加工的变量) for 变量 in iterable]

​    2.筛选模式: [变量(加工的变量) for 变量 in iterable if 条件]

当然还有多层循环的，这个我们一会就会讲到，那么我们先来看循环模式。

#### **1.1.1 循环模式**

刚才我们看到的就是循环模式，那么有同学会问到，什么叫' 加工的变量'? 这个也比较简单，接下来我们做几道题：

1. 将10以内所有整数的平方写入列表。

```
l1 = [i*i for i in range(1,11)]
print(l1)
 
```

1. 100以内所有的偶数写入列表.

```
l1 = [i for i in range(2,101,2)]
print(l1)
 
```

1. 从python1期到python24期写入列表lst

```
lst = [f'python{i}' % i for i in range(1,25)]

print(lst)
```

上面那个格式化输出的变量f'python{i}'，就是加工的变量。

上面做的那三个就是循环模式，比较简单，接下来我们研究筛选模式。

#### 1.1.2 筛选模式

筛选模式就是在上面的基础上加上一个判断条件，将满足条件的变量留到列表中。

**带着同学们做一个题：**

将这个列表中大于3的元素留下来。

```
l1 = [4, 3, 2, 6, 5, 5, 7, 8] 
print([i for i in l1 if i > 3])
```

通过我给大家的演示，大家做几道题：

1. 三十以内可以被三整除的数。

   ```
   multiples = [i for i in range(30) if i % 3 is 0]
   print(multiples)
   ```

2. 过滤掉长度小于3的字符串列表，并将剩下的转换成大写字母

   ```
   l = ['wusir', 'laonanhai', 'aa', 'b', 'taibai']
   # print([i.upper() for i in l if len(i) > 3])
   ```

3. 找到嵌套列表中名字含有两个‘e’的所有名字（**有难度**）

   ```
   names = [['Tom', 'Billy', 'Jefferson', 'Andrew', 'Wesley', 'Steven', 'Joe'],
            ['Alice', 'Jill', 'Ana', 'Wendy', 'Jennifer', 'Sherry', 'Eva']]
   
   print([name for lst in names for name in lst if name.count('e') >= 2])  
   # 注意遍历顺序，这是实现的关键
   ```

列表推导式基本上讲完了，当然今天会做一些有关列表推导式的题，让大家更加深入的了解。

#### **1.1.3 生成器表达式**

生成器表达式和列表推导式的语法上一模一样,只是把[]换成()就行了。比如将十以内所有数的平方放到一个生成器表达式中

```
gen = (i**2 for i in range(10))
print(gen)
# 结果: <generator object <genexpr> at 0x0000026046CAEBF8>
```

生成器表达式也可以进行筛选

```
# 获取1-100内能被3整除的数
gen = (i for i in range(1,100) if i % 3 == 0)
for num in gen:
    print(num)
```

**生成器表达式和列表推导式的区别:**

1. 列表推导式比较耗内存,所有数据一次性加载到内存。而生成器表达式遵循迭代器协议，逐个产生元素。
2. 得到的值不一样,列表推导式得到的是一个列表.生成器表达式获取的是一个生成器
3. 列表推导式一目了然，生成器表达式只是一个内存地址。

​    无论是生成器表达式，还是列表推导式，他只是Python给你提供了一个相对简单的构造方式，因为使用推导式非常简单，所以大多数都会为之着迷，这个一定要慎重，推导式只能构建相对复杂的并且有规律的对象，对于没有什么规律，而且嵌套层数比较多（for循环超过三层）这样就不建议大家用推导式构建。

生成器的惰性机制: 生成器只有在访问的时候才取值,说白了.你找他要才给你值.不找他要.他是不会执行的.

#### **1.1.4 其他相关的推导式（了解）**

#####  **字典推导式**

根据名字应该也能猜到,推到出来的是字典

```
lst1 = ['jay','jj','meet']
lst2 = ['周杰伦','林俊杰','郭宝元']
dic = {lst1[i]:lst2[i] for i in range(len(lst1))}
print(dic)
```

**集合推导式**

集合推导式可以帮我们直接生成一个集合,集合的特点;无序,不重复 所以集合推导式自带去重功能

```
lst = [1,2,3,-1,-3,-7,9]
s = {abs(i) for i in lst}
print(s)
```

