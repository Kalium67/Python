## 一. 函数参数-动态参数

之前我们说过传参,如果我们在传参数的时候不很清楚有哪些的时候,或者说给一个函数传了很多参数,我们就要写很多,很麻烦怎么办呢,我们可以考虑使用动态参数

形参的第三种:动态参数

首先我们来回顾下位置参数

```
def eat(a,b,c):

    print('我想吃%s%s%s'%(a,b,c))

eat('大米饭','中米饭','小米饭')
```

现在有个问题,你们看我这体型也知道吃的不止这些,数量也没有写,这时我们就要用到动态参数　　

### 1.1 动态接收位置参数

在参数位置用*表示接受任意参数

```
def eat(*args):

    print('我想吃',args)

eat('大米饭','中米饭','小米饭')  # 收到的结果是一个tuple元祖
```

动态接收参数的时候要注意: 动态参数必须在位置参数后面

```
def eat(*args,a,b):

    print('我想吃',args,a,b)

eat('大米饭','中米饭','小米饭')

结果:

TypeError: eat() missing 2 required keyword-only arguments: 'a' and 'b'
# eat函数在调用的时候发现缺少俩个位置参数没有进行传递
```

通过上述代码发现一个问题就是,我们明明给了多个参数,为什么还会提示参数未传递呢?

原因就是因为这个*在搞鬼  \*把所有的位置参数都给接受了,所有会报错.我们尝试着把a,b放在\*的前面试试

```
def eat(a,b,*args):

    print('我想吃',args,a,b)

eat('大米饭','中米饭','小米饭')

结果:

我想吃 ('小米饭',) 大米饭 中米饭
```

动态接收参数的时候要注意:动态参数必须在位置参数后面

那默认值参数呢?

```
def eat(a,b,c='白菜',*args):

    print('我想吃',a,b,c,args)

eat('豆腐','粉条','猪肉','大葱')

结果:

我想吃 豆腐 粉条 猪肉 ('大葱',)  # 我们定义好的白菜没有生效,被猪肉给覆盖了
```

我们发现默认值参数写在动态参数前面,默认值的参数是不会生效的

```
def eat(a,b,*args,c='白菜'):

    print('我想吃',a,b,args,c)

eat('猪肉','粉条','豆腐','大葱')

结果:

我想吃 猪肉 粉条 ('豆腐', '大葱') 白菜  # 这样默认参数就生效了
```

这个时候如果你不给出关键字传参,那么你的默认值是永远都生效的　　

注意: 形参的顺序:  位置参数 , 动态参数 , 默认参数

### 1.2 动态接收关键字参数

在python中可以动态的位置参数,但是*这种情况只能接收位置参数无法接收关键字参数,在python中使用**来接收动态关键字参数

```
def func(**kwargs):

    print(kwargs)     

func(a=1, b=2, c=3)

结果:

{'a': 1, 'b': 2, 'c': 3}
```

动态关键字参数最后获取的是一个dict字典形式　　

顺序的问题, 在函数调用的时候, 如果先给出关键字参数, 则整个参数列表会报错.

```
def func(a,b,c,d):

    print(a,b,c,d)

func(1,2,c=3,4)

结果:

  File "D:/python_object/path2/test.py", line 806

    func(1,2,c=3,4)              ^

SyntaxError: positional argument follows keyword argument
```

关键参数必须要放在位置参数后边,由于实参是这个顺序,所以形参接收的时候也是这个顺序.也就是说位置参数必须在关键字参数前面.动态接收关键字参数也要在后面

最终顺序:

　　位置参数 > *args(动态位置参数)  > 默认值参数 > **kwargs(动态默认参数)

　　这四种参数可以任意的使用 

如果想接收所有的参数:

```
def func(*args,**kwargs):

    print(args,kwargs)

func(1,23,5,a=1,b=6)
```

动态参数还可以这样传参:

```
lst = [1,4,7]

# 方法一

def func(*args):

    print(args)

func(lst[0],lst[1],lst[2])



# 方法二

def func(*args):

    print(args)

func(*lst)  
# 在实参的位置上用*将lst(可迭代对象)按照顺序打散

# 在形参的位置上用*把收到的参数组合成一个元祖
```

字典也可以进行打散,不过需要**

```
dic = {'a':1,'b':2}

def func(**kwargs):

    print(kwargs)

func(**dic)
```

## 